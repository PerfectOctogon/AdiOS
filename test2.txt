
kernel/arch/x86_64/boot.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <_start>:
.type _start, @function
.extern long_mode_start

.code32
_start:
	movl $stack_top, %esp
   0:	bc 00 00 00 00       	mov    $0x0,%esp
	# Call the global constructors.
	# call _init Not writing C++ code right now, so don't need to call the global constructors! (Also this doesn't really work right now)
	# Lets check for cpuid
	call checkcpuid
   5:	e8 49 00 00 00       	call   53 <checkcpuid>

	# Lets check for extended functionality
	call checkextfunc
   a:	e8 5c 00 00 00       	call   6b <checkextfunc>

	# Now, lets set up page tables
	call setup_pagetables
   f:	e8 79 00 00 00       	call   8d <setup_pagetables>

	# Now, we can enable paging
	jmp enable_pae_paging
  14:	e9 b9 00 00 00       	jmp    d2 <enable_pae_paging>

0000000000000019 <load_gdt>:
	
	.code64
	load_gdt:
	mov $(null_gdtr - 0xFFFF800000000000), %eax
  19:	b8 00 00 00 00       	mov    $0x0,%eax
    lgdt (%eax)
  1e:	67 0f 01 10          	lgdt   (%eax)

	// sgdt gdtr_dump
	// lgdt .pointer
	// sgdt gdtr_dump
	.code64
	movabsq $long_mode_start, %rax
  22:	48 b8 00 00 00 00 00 	movabs $0x0,%rax
  29:	00 00 00 
	// // movabs
	jmp *%rax
  2c:	ff e0                	jmp    *%rax
  2e:	66 90                	xchg   %ax,%ax

0000000000000030 <null_gdtr>:
  30:	18 00                	sbb    %al,(%rax)
	...

000000000000003a <null_gdt_base>:
	...
  46:	00 9a 20 00 ff ff    	add    %bl,-0xffe0(%rdx)
  4c:	00 00                	add    %al,(%rax)
  4e:	00 92 00 00      	add    %dl,-0x630c0000(%rdx)

0000000000000052 <null_gdt_end>:
		.byte 0
		.byte 0x92
		.byte 0
		.byte 0
	null_gdt_end:
	hlt
  52:	f4                   	hlt

0000000000000053 <checkcpuid>:
.size _start, . - _start

.code32
# Check if CPUID exists
checkcpuid:
	pushf # Dump CPU flags into the stack
  53:	9c                   	pushf
	popl %eax # Pop the flags into the EAX register
  54:	58                   	pop    %rax
	movl %eax, %ecx # Storing a copy of these flags so we don't end up modifying the CPU flags
  55:	89 c1                	mov    %eax,%ecx
	xor $(1 << 21), %eax # Flipping the 21st bit. If we can flip this, we can use CPUID
  57:	35 00 00 20 00       	xor    $0x200000,%eax
	pushl %eax # Push the modified flags into the stack
  5c:	50                   	push   %rax
	popf # Put the modified flags into the CPU flags register
  5d:	9d                   	popf
	pushf # Lets check if the bit was flipped and restore the flags
  5e:	9c                   	pushf
	popl %eax
  5f:	58                   	pop    %rax
	pushl %ecx # ECX contains our original copy of our flags
  60:	51                   	push   %rcx
	popf # Restore the flags
  61:	9d                   	popf
	cmpl %eax, %ecx # Let's compare EAX and ECX
  62:	39 c1                	cmp    %eax,%ecx
	jz .nocpuid # If zero flag was set, then the bit was not flipped, so jump to nocpuid error
  64:	0f 84 97 00 00 00    	je     101 <.nocpuid>
	ret
  6a:	c3                   	ret

000000000000006b <checkextfunc>:

# Check if extended functionality exists
checkextfunc:
	mov $0x80000000, %eax # Function number for querying extended functionality
  6b:	b8 00 00 00 80       	mov    $0x80000000,%eax
	cpuid
  70:	0f a2                	cpuid
	cmp $0x80000001, %eax # Check if EAX got larger
  72:	3d 01 00 00 80       	cmp    $0x80000001,%eax
	jb .noextfunc
  77:	0f 82 88 00 00 00    	jb     105 <.noextfunc>

	mov $0x80000001, %eax
  7d:	b8 01 00 00 80       	mov    $0x80000001,%eax
	cpuid # This will now store various CPU information into different registers
  82:	0f a2                	cpuid
	test $(1 << 29), %edx # Checking the 30th youngest bit of the EDX register to see if we have long mode support
  84:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
	jz .nolongmode # If it's 0, we don't have long mode support
  8a:	74 7d                	je     109 <.nolongmode>
	ret
  8c:	c3                   	ret

000000000000008d <setup_pagetables>:

setup_pagetables:
	# Temporarily disable paging
	mov %cr0, %eax
  8d:	0f 20 c0             	mov    %cr0,%rax
	and $~(1 << 31), %eax # Reset the oldest bit in control register 0
  90:	25 ff ff ff 7f       	and    $0x7fffffff,%eax
	mov %eax, %cr0
  95:	0f 22 c0             	mov    %rax,%cr0

0000000000000098 <setup_page_tables>:

	setup_page_tables:
    # Load address of page_table_l3 into %eax
    movl $pdpt, %eax
  98:	b8 00 00 00 00       	mov    $0x0,%eax
    orl $0b11, %eax              # Present, writable
  9d:	83 c8 03             	or     $0x3,%eax
    movl %eax, pml4t      # Store in L4 table
  a0:	a3 00 00 00 00 b8 00 	movabs %eax,0xb800000000
  a7:	00 00 

    # Load address of page_table_l2 into %eax
    movl $pd, %eax
  a9:	00 83 c8 03 a3 00    	add    %al,0xa303c8(%rbx)
    orl $0b11, %eax              # Present, writable
    movl %eax, pdpt      # Store in L3 table
  af:	00 00                	add    %al,(%rax)
  b1:	00 31                	add    %dh,(%rcx)

    xorl %ecx, %ecx              # Zero out ECX counter
  b3:	c9                   	leave

00000000000000b4 <.loop>:

	.loop:
		movl $0x200000, %eax         # Load 2MB page size
  b4:	b8 00 00 20 00       	mov    $0x200000,%eax
		mull %ecx                    # Multiply by ECX (EDX:EAX result)
  b9:	f7 e1                	mul    %ecx
		orl $0b10000011, %eax        # Present, writable, huge page flag
  bb:	0d 83 00 00 00       	or     $0x83,%eax
		movl %eax, pd(,%ecx,8) # Store at page_table_l2 + ECX * 8
  c0:	89 04 cd 00 00 00 00 	mov    %eax,0x0(,%rcx,8)
		incl %ecx                    # Increment ECX
  c7:	41 81 f9 00 02 00 00 	cmp    $0x200,%r9d
		cmpl $512, %ecx              # Check if whole table is mapped
		jne .loop                    # If not, continue loop
  ce:	75 e4                	jne    b4 <.loop>

		ret
  d0:	c3                   	ret
	// 	or $0x83, %eax # Setting flags
	// 	movl %eax, 0x3000(,%ecx,8)
	// 	inc %ecx
	// 	cmp $0x200, %ecx
	// 	jne .idmap
	ret
  d1:	c3                   	ret

00000000000000d2 <enable_pae_paging>:
enable_pae_paging:
	mov $pml4t, %eax # Address of the PML4T
  d2:	b8 00 00 00 00       	mov    $0x0,%eax
	mov %eax, %cr3 # Move this address to the control register 3
  d7:	0f 22 d8             	mov    %rax,%cr3

	mov %cr4, %eax # Enable PAE paging
  da:	0f 20 e0             	mov    %cr4,%rax
	or $(1 << 5), %eax
  dd:	83 c8 20             	or     $0x20,%eax
	mov %eax, %cr4
  e0:	0f 22 e0             	mov    %rax,%cr4

00000000000000e3 <.enter_long_mode>:

	# Now the cr3 register knows where our PML4T is
	.enter_long_mode:
		mov $0xC0000080, %ecx # Move model specific register into ECX
  e3:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
		rdmsr # Write the register value into EAX
  e8:	0f 32                	rdmsr
		or $(1 << 8), %eax # Set 8th bit, which is responsible for enabling long mode when we enable paging
  ea:	0d 00 01 00 00       	or     $0x100,%eax
		wrmsr # Write to the model specific register
  ef:	0f 30                	wrmsr

00000000000000f1 <.enable_paging>:
	
	.enable_paging:
		mov %cr0, %eax
  f1:	0f 20 c0             	mov    %cr0,%rax
		or $(1 << 31), %eax # Flipping the oldest bit in control register 0
  f4:	0d 00 00 00 80       	or     $0x80000000,%eax
		mov %eax, %cr0
  f9:	0f 22 c0             	mov    %rax,%cr0
	
	// movl $0xb8000, %eax
	// movl $0x4f524f45, (%eax)
	# Paging is now enabled !!!!!!!!! :D
	jmp load_gdt # Far jump to reload the CS --> This long jump is messing stuff up >:(
  fc:	e9 18 ff ff ff       	jmp    19 <load_gdt>

0000000000000101 <.nocpuid>:

.nocpuid:
	movb $'C', %al
 101:	b0 43                	mov    $0x43,%al
	jmp error
 103:	eb 08                	jmp    10d <error>

0000000000000105 <.noextfunc>:

.noextfunc:
	movb $'E', %al
 105:	b0 45                	mov    $0x45,%al
	jmp error
 107:	eb 04                	jmp    10d <error>

0000000000000109 <.nolongmode>:

.nolongmode:
	movb $'L', %al
 109:	b0 4c                	mov    $0x4c,%al
	jmp error
 10b:	eb 00                	jmp    10d <error>

000000000000010d <error>:

error:
    movl $0x4f524f45, 0xb8000
 10d:	c7 05 00 80 0b 00 45 	movl   $0x4f524f45,0xb8000(%rip)        # b8117 <stack_top+0xb0117>
 114:	4f 52 4f 
    movl $0x4f3a4f53, 0xb8004
 117:	c7 05 04 80 0b 00 53 	movl   $0x4f3a4f53,0xb8004(%rip)        # b8125 <stack_top+0xb0125>
 11e:	4f 3a 4f 
    movl $0x4f204f20, 0xb8008
 121:	c7 05 08 80 0b 00 20 	movl   $0x4f204f20,0xb8008(%rip)        # b8133 <stack_top+0xb0133>
 128:	4f 20 4f 
    mov %al, 0xb800a
 12b:	a2                   	.byte 0xa2
 12c:	0a                   	.byte 0xa
 12d:	80 0b 00             	orb    $0x0,(%rbx)
    hlt
 130:	f4                   	hlt

Disassembly of section .multiboot:

0000000000000000 <.multiboot>:
	movl $stack_top, %esp
   0:	02 b0 ad 1b 03 00    	add    0x31bad(%rax),%dh
	call checkcpuid
   6:	00 00                	add    %al,(%rax)
   8:	fb                   	sti
   9:	4f 52                	rex.WRXB push %r10
	call checkextfunc
   b:	e4                   	.byte 0xe4

Disassembly of section .note.gnu.property:

0000000000000000 <.note.gnu.property>:
   0:	04 00                	add    $0x0,%al
   2:	00 00                	add    %al,(%rax)
   4:	20 00                	and    %al,(%rax)
   6:	00 00                	add    %al,(%rax)
   8:	05 00 00 00 47       	add    $0x47000000,%eax
   d:	4e 55                	rex.WRX push %rbp
   f:	00 02                	add    %al,(%rdx)
  11:	00 01                	add    %al,(%rcx)
  13:	c0 04 00 00          	rolb   $0x0,(%rax,%rax,1)
  17:	00 01                	add    %al,(%rcx)
  19:	00 00                	add    %al,(%rax)
  1b:	00 00                	add    %al,(%rax)
  1d:	00 00                	add    %al,(%rax)
  1f:	00 01                	add    %al,(%rcx)
  21:	00 01                	add    %al,(%rcx)
  23:	c0 04 00 00          	rolb   $0x0,(%rax,%rax,1)
  27:	00 01                	add    %al,(%rcx)
  29:	00 00                	add    %al,(%rax)
  2b:	00 00                	add    %al,(%rax)
  2d:	00 00                	add    %al,(%rax)
	...

Disassembly of section .debug_line:

0000000000000000 <.debug_line>:
	movl $stack_top, %esp
   0:	91                   	xchg   %eax,%ecx
   1:	00 00                	add    %al,(%rax)
   3:	00 02                	add    %al,(%rdx)
	call checkcpuid
   5:	00 26                	add    %ah,(%rsi)
   7:	00 00                	add    %al,(%rax)
   9:	00 01                	add    %al,(%rcx)
	call checkextfunc
   b:	01 fb                	add    %edi,%ebx
   d:	0e                   	(bad)
   e:	0a 00                	or     (%rax),%al
	call setup_pagetables
  10:	01 01                	add    %eax,(%rcx)
  12:	01 01                	add    %eax,(%rcx)
	jmp enable_pae_paging
  14:	00 00                	add    %al,(%rax)
  16:	00 01                	add    %al,(%rcx)
  18:	61                   	(bad)
	mov $(null_gdtr - 0xFFFF800000000000), %eax
  19:	72 63                	jb     7e <.debug_line+0x7e>
  1b:	68 2f 78 38 36       	push   $0x3638782f
    lgdt (%eax)
  20:	5f                   	pop    %rdi
  21:	36 34 00             	ss xor $0x0,%al
	movabsq $long_mode_start, %rax
  24:	00 62 6f             	add    %ah,0x6f(%rdx)
  27:	6f                   	outsl  %ds:(%rsi),(%dx)
  28:	74 2e                	je     58 <.debug_line+0x58>
  2a:	53                   	push   %rbx
  2b:	00 01                	add    %al,(%rcx)
	jmp *%rax
  2d:	00 00                	add    %al,(%rax)
  2f:	00 00                	add    %al,(%rax)
  31:	09 02                	or     %eax,(%rdx)
	...
  3b:	03 17                	add    (%rdi),%edx
  3d:	01 59 58             	add    %ebx,0x58(%rcx)
  40:	58                   	pop    %rax
  41:	58                   	pop    %rax
  42:	59                   	pop    %rcx
  43:	56                   	push   %rsi
  44:	03 0a                	add    (%rdx),%ecx
  46:	47 9d                	rex.RXB popf
  48:	03 17                	add    (%rdi),%edx
  4a:	02 26                	add    (%rsi),%ah
  4c:	01 23                	add    %esp,(%rbx)
  4e:	1e                   	(bad)
  4f:	1e                   	(bad)
  50:	2c 56                	sub    $0x56,%al
	hlt
  52:	1e                   	(bad)
	pushf # Dump CPU flags into the stack
  53:	1e                   	(bad)
	popl %eax # Pop the flags into the EAX register
  54:	1e                   	(bad)
	movl %eax, %ecx # Storing a copy of these flags so we don't end up modifying the CPU flags
  55:	1e                   	(bad)
  56:	1e                   	(bad)
	xor $(1 << 21), %eax # Flipping the 21st bit. If we can flip this, we can use CPUID
  57:	1e                   	(bad)
  58:	2c 64                	sub    $0x64,%al
  5a:	21 56 2c             	and    %edx,0x2c(%rsi)
	popf # Put the modified flags into the CPU flags register
  5d:	56                   	push   %rsi
	pushf # Lets check if the bit was flipped and restore the flags
  5e:	65 56                	gs push %rsi
	pushl %ecx # ECX contains our original copy of our flags
  60:	2c 64                	sub    $0x64,%al
	cmpl %eax, %ecx # Let's compare EAX and ECX
  62:	2c 21                	sub    $0x21,%al
	jz .nocpuid # If zero flag was set, then the bit was not flipped, so jump to nocpuid error
  64:	3a 56 3d             	cmp    0x3d(%rsi),%dl
  67:	56                   	push   %rsi
  68:	3a 58 56             	cmp    0x56(%rax),%bl
	mov $0x80000000, %eax # Function number for querying extended functionality
  6b:	3a 57 2e             	cmp    0x2e(%rdi),%dl
  6e:	56                   	push   %rsi
  6f:	2c 56                	sub    $0x56,%al
	cpuid
  71:	72 1e                	jb     91 <.debug_line+0x91>
	cmp $0x80000001, %eax # Check if EAX got larger
  73:	64 2d 03 11 1d 1f    	fs sub $0x1f1d1103,%eax
	jb .noextfunc
  79:	56                   	push   %rsi
  7a:	3b 3a                	cmp    (%rdx),%edi
  7c:	3a 3d 56 2c 56 2e    	cmp    0x2e562c56(%rip),%bh        # 2e562cd8 <MAGIC+0x12a87cd6>
	cpuid # This will now store various CPU information into different registers
  82:	3a 56 3e             	cmp    0x3e(%rsi),%dl
	test $(1 << 29), %edx # Checking the 30th youngest bit of the EDX register to see if we have long mode support
  85:	58                   	pop    %rax
  86:	2c 2e                	sub    $0x2e,%al
  88:	2c 2e                	sub    $0x2e,%al
	jz .nolongmode # If it's 0, we don't have long mode support
  8a:	2c 2e                	sub    $0x2e,%al
	ret
  8c:	9c                   	pushf
	mov %cr0, %eax
  8d:	9c                   	pushf
  8e:	9c                   	pushf
  8f:	56                   	push   %rsi
	and $~(1 << 31), %eax # Reset the oldest bit in control register 0
  90:	02 01                	add    (%rcx),%al
  92:	00 01                	add    %al,(%rcx)
  94:	01                   	.byte 0x1

Disassembly of section .debug_info:

0000000000000000 <.debug_info>:
	movl $stack_top, %esp
   0:	41 00 00             	add    %al,(%r8)
   3:	00 02                	add    %al,(%rdx)
	call checkcpuid
   5:	00 00                	add    %al,(%rax)
   7:	00 00                	add    %al,(%rax)
   9:	00 08                	add    %cl,(%rax)
	call checkextfunc
   b:	01 00                	add    %eax,(%rax)
	...
	movabsq $long_mode_start, %rax
  29:	00 00                	add    %al,(%rax)
  2b:	00 01                	add    %al,(%rcx)
	jmp *%rax
  2d:	80 02 00             	addb   $0x0,(%rdx)
  30:	00 00                	add    %al,(%rax)
  32:	00 01                	add    %al,(%rcx)
	...

Disassembly of section .debug_abbrev:

0000000000000000 <.debug_abbrev>:
	movl $stack_top, %esp
   0:	01 11                	add    %edx,(%rcx)
   2:	01 10                	add    %edx,(%rax)
   4:	06                   	(bad)
	call checkcpuid
   5:	11 01                	adc    %eax,(%rcx)
   7:	12 01                	adc    (%rcx),%al
   9:	03 0e                	add    (%rsi),%ecx
	call checkextfunc
   b:	1b 0e                	sbb    (%rsi),%ecx
   d:	25 0e 13 05 00       	and    $0x5130e,%eax
	call setup_pagetables
  12:	00 02                	add    %al,(%rdx)
	jmp enable_pae_paging
  14:	2e 00 03             	cs add %al,(%rbx)
  17:	0e                   	(bad)
  18:	3f                   	(bad)
	mov $(null_gdtr - 0xFFFF800000000000), %eax
  19:	0c 11                	or     $0x11,%al
  1b:	01 12                	add    %edx,(%rdx)
  1d:	01 00                	add    %eax,(%rax)
	...

Disassembly of section .debug_aranges:

0000000000000000 <.debug_aranges>:
	movl $stack_top, %esp
   0:	2c 00                	sub    $0x0,%al
   2:	00 00                	add    %al,(%rax)
   4:	02 00                	add    (%rax),%al
	call checkcpuid
   6:	00 00                	add    %al,(%rax)
   8:	00 00                	add    %al,(%rax)
	call checkextfunc
   a:	08 00                	or     %al,(%rax)
	...
	jmp enable_pae_paging
  18:	31 01                	xor    %eax,(%rcx)
	...

Disassembly of section .debug_str:

0000000000000000 <.debug_str>:
	movl $stack_top, %esp
   0:	61                   	(bad)
   1:	72 63                	jb     66 <checkcpuid+0x13>
   3:	68 2f 78 38 36       	push   $0x3638782f
	call checkcpuid
   8:	5f                   	pop    %rdi
   9:	36 34 2f             	ss xor $0x2f,%al
	call checkextfunc
   c:	62                   	(bad)
   d:	6f                   	outsl  %ds:(%rsi),(%dx)
   e:	6f                   	outsl  %ds:(%rsi),(%dx)
	call setup_pagetables
   f:	74 2e                	je     3f <.debug_str+0x3f>
  11:	53                   	push   %rbx
  12:	00 2f                	add    %ch,(%rdi)
	jmp enable_pae_paging
  14:	68 6f 6d 65 2f       	push   $0x2f656d6f
	mov $(null_gdtr - 0xFFFF800000000000), %eax
  19:	61                   	(bad)
  1a:	64 69 74 68 79 61 2f 	imul   $0x6f442f61,%fs:0x79(%rax,%rbp,2),%esi
  21:	44 6f 
	movabsq $long_mode_start, %rax
  23:	63 75 6d             	movsxd 0x6d(%rbp),%esi
  26:	65 6e                	outsb  %gs:(%rsi),(%dx)
  28:	74 73                	je     9d <setup_page_tables+0x5>
  2a:	2f                   	(bad)
  2b:	41                   	rex.B
	jmp *%rax
  2c:	64 69 4f 53 2f 41 64 	imul   $0x6964412f,%fs:0x53(%rdi),%ecx
  33:	69 
  34:	4f 53                	rex.WRXB push %r11
  36:	2f                   	(bad)
  37:	6b 65 72 6e          	imul   $0x6e,0x72(%rbp),%esp
  3b:	65 6c                	gs insb (%dx),%es:(%rdi)
  3d:	00 47 4e             	add    %al,0x4e(%rdi)
  40:	55                   	push   %rbp
  41:	20 41 53             	and    %al,0x53(%rcx)
  44:	20 32                	and    %dh,(%rdx)
  46:	2e 34 34             	cs xor $0x34,%al
  49:	00 5f 73             	add    %bl,0x73(%rdi)
  4c:	74 61                	je     af <setup_page_tables+0x17>
  4e:	72 74                	jb     c4 <.loop+0x10>
	...
